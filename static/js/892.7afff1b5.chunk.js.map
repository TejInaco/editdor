{"version":3,"file":"static/js/892.7afff1b5.chunk.js","mappings":"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","sources":["external/shared.js","external/TdPlayground.js","util.js","workers/validationWorker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":[" /**\n  * This file contains functions, which are required by the core package as\n  * well as by the assertions package\n  */\n\n// A special JSON validator that is used only to check whether the given object has duplicate keys.\n// The standard library doesn't detect duplicate keys and overwrites the first one with the second one.\n// TODO: replace with jsonlint ??\nimport jsonValidator from 'json-dup-key-validator';\n\n\n// This is used to validate if the multi language JSON keys are valid according to the BCP47 spec\nconst bcp47pattern = /^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|\\d{3}))?((?:-(?:[\\da-z]{5,8}|\\d[\\da-z]{3}))*)?((?:-[\\da-wy-z](?:-[\\da-z]{2,8})+)*)?(-x(?:-[\\da-z]{1,8})+)?$|^(x(?:-[\\da-z]{1,8})+)$/i // eslint-disable-line max-len\n\n\nexport {\n    checkPropUniqueness,\n    checkSecurity,\n    checkMultiLangConsistency,\n    checkLinksRelTypeCount,\n    checkUriSecurity,\n    checkTmOptionalPointer\n}\n\n/**\n * This function returns part of the object given in param with the value found when resolving the path. Similar to JSON Pointers.\n * In case no path is found, the param defaultValue is echoed back\n * Taken from\n * https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-and-arrays-by-string-path/6491621#6491621\n * @param {object} object\n * @param {string} path\n * @param {any} defaultValue\n * @return {object}\n **/\nconst resolvePath = (object, path, defaultValue) => path\n    //eslint-disable-next-line\n    .split(/[\\.\\[\\]\\'\\\"]/)\n    .filter(p => p)\n    .reduce((o, p) => o ? o[p] : defaultValue, object)\n\n// -------------------------------------------------- checkPropUniqueness\n\n/**\n *  Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp\n *  However, if there are no properties then it is not-impl\n *\n * @param {string} tdString The Td under test as string\n */\nfunction checkPropUniqueness(tdString) {\n\n    const results = []\n\n    // jsonvalidator throws an error if there are duplicate names in the interaction level\n    try {\n        jsonValidator.parse(tdString, false)\n\n        const td = JSON.parse(tdString)\n\n        // no problem in interaction level\n        //eslint-disable-next-line\n        // let tdInteractions = [] // not used\n\n        // checking whether there are properties at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"properties\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.properties)) // not used\n            // then we can add unique properties pass\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique properties as not impl\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no properties\"\n            })\n        }\n\n        // similar to just before, checking whether there are actions at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"actions\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.actions)) // not used\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique actions as not impl\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no actions\"\n            })\n        }\n\n        // similar to just before, checking whether there are events at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"events\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.events)) // not used\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique events as not impl\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no events\"\n            })\n        }\n\n        return results\n\n    } catch (error) {\n        // there is a duplicate somewhere\n\n        // convert it into string to be able to process it\n        // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n        const errorString = error.toString()\n        // to get the name, we need to remove the quotes around it\n        const startQuote = errorString.indexOf('\"')\n        // slice to remove the part before the quote\n        const restString = errorString.slice(startQuote + 1)\n        // find where the interaction name ends\n        const endQuote = restString.indexOf('\"')\n        // finally get the interaction name\n        const interactionName = restString.slice(0, endQuote)\n\n        // trying to find where this interaction is and put results accordingly\n        const td = JSON.parse(tdString)\n\n        if (td.hasOwnProperty(\"properties\")) {\n            const tdProperties = td.properties\n            if (tdProperties.hasOwnProperty(interactionName)) {\n                // duplicate was at properties but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-properties_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate property names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n\n            } else {\n                // there is duplicate but not here, so pass\n                results.push({\n                    \"ID\": \"td-properties_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no properties\"\n            })\n        }\n\n        if (td.hasOwnProperty(\"actions\")) {\n            const tdActions = td.actions\n            if (tdActions.hasOwnProperty(interactionName)) {\n                // duplicate was at actions but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-actions_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate action names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n            } else {\n                results.push({\n                    \"ID\": \"td-actions_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no actions\"\n            })\n        }\n\n        if (td.hasOwnProperty(\"events\")) {\n            const tdEvents = td.events\n            if (tdEvents.hasOwnProperty(interactionName)) {\n                // duplicate was at events but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-events_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate event names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n            } else {\n                results.push({\n                    \"ID\": \"td-events_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no events\"\n            })\n        }\n\n        return results\n    }\n}\n\n\n// -------------------------------------------------- checkSecurity\n\n/**\n * check if used Security definitions are properly defined previously\n * @param {object} td The TD to do assertion tests\n */\nfunction checkSecurity(td) {\n\n    const results = []\n    if (td.hasOwnProperty(\"securityDefinitions\")) {\n        const securityDefinitionsObject = td.securityDefinitions\n        const securityDefinitions = Object.keys(securityDefinitionsObject)\n\n\n        const rootSecurity = td.security\n\n        if (securityContains(securityDefinitions, rootSecurity)) {\n            // all good\n        } else {\n            results.push({\n                \"ID\": \"td-security-scheme-name\",\n                \"Status\": \"fail\",\n                \"Comment\": \"used a non defined security scheme in root level\"\n            })\n            return results\n        }\n\n        if (td.hasOwnProperty(\"properties\")) {\n            // checking security in property level\n            let tdProperties = Object.keys(td.properties)\n            for (let i = 0; i < tdProperties.length; i++) {\n                const curPropertyName = tdProperties[i]\n                const curProperty = td.properties[curPropertyName]\n\n                // checking security in forms level\n                const curForms = curProperty.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in a property form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n            }\n        }\n\n        if (td.hasOwnProperty(\"actions\")) {\n            // checking security in action level\n            let tdActions = Object.keys(td.actions)\n            for (let i = 0; i < tdActions.length; i++) {\n                const curActionName = tdActions[i]\n                const curAction = td.actions[curActionName]\n\n                // checking security in forms level\n                const curForms = curAction.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in an action form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n\n            }\n        }\n\n        if (td.hasOwnProperty(\"events\")) {\n            // checking security in event level\n            let tdEvents = Object.keys(td.events)\n            for (let i = 0; i < tdEvents.length; i++) {\n                const curEventName = tdEvents[i]\n                const curEvent = td.events[curEventName]\n\n                // checking security in forms level\n                const curForms = curEvent.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in an event form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n\n            }\n        }\n\n        // no security used non defined scheme, passed test\n        results.push({\n            \"ID\": \"td-security-scheme-name\",\n            \"Status\": \"pass\"\n        })\n        return results\n\n    }\n    return results\n}\n\n/**\n * subfunction of checkSecurity\n * security anywhere could be a string or array. Convert string to array\n *\n * @param {*} parent\n * @param {string|Array<string>} child\n */\nfunction securityContains(parent, child) {\n\n    if (typeof child === \"string\") {\n        child = [child]\n    }\n    return child.every(elem => parent.indexOf(elem) > -1)\n}\n\n\n// -------------------------------------------------- checkMultiLangConsistency\n\n/**\n *  this checks whether all titles and descriptions have the same language fields\n *  so the object keys of a titles and of a descriptions should be the same already,\n *  then everywhere else they should also be the same\n *\n *  first collect them all, and then compare them\n *\n * @param {object} td The TD to do assertion tests\n */\nfunction checkMultiLangConsistency(td) {\n\n    const results = []\n    const multiLang = [] // an array of arrays where each small array has the multilang keys\n    const isTdTitlesDescriptions = [] // an array of boolean values to check td-titles-descriptions assertion\n\n    // checking root\n    if (td.hasOwnProperty(\"titles\")) {\n        const rootTitlesObject = td.titles\n        const rootTitles = Object.keys(rootTitlesObject)\n        multiLang.push(rootTitles)\n        // checking for td-titles-descriptions\n        //eslint-disable-next-line\n        isTdTitlesDescriptions.push({[\"root_title\"]: isStringObjectKeyValue(td.title, rootTitlesObject)})\n    }\n\n    if (td.hasOwnProperty(\"descriptions\")) {\n        const rootDescriptionsObject = td.descriptions\n        const rootDescriptions = Object.keys(rootDescriptionsObject)\n        multiLang.push(rootDescriptions)\n        // check whether description exists in descriptions\n        if (td.hasOwnProperty(\"description\")) {\n            //eslint-disable-next-line\n            isTdTitlesDescriptions.push({[\"root_description\"]: isStringObjectKeyValue(td.description, rootDescriptionsObject)})\n        }\n    }\n\n    // checking inside each interaction\n    if (td.hasOwnProperty(\"properties\")) {\n        // checking security in property level\n        let tdProperties = Object.keys(td.properties)\n        for (let i = 0; i < tdProperties.length; i++) {\n            const curPropertyName = tdProperties[i]\n            const curProperty = td.properties[curPropertyName]\n\n            if (curProperty.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curProperty.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curProperty.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"property_\"+curPropertyName + \"_title\"]: isStringObjectKeyValue(curProperty.title, curProperty.titles)\n                    })\n                }\n            }\n\n            if (curProperty.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curProperty.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curProperty.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                    [\"property_\" + curPropertyName + \"_desc\"]: isStringObjectKeyValue(curProperty.description,curProperty.descriptions)\n                    })\n                }\n            }\n        }\n    }\n\n    if (td.hasOwnProperty(\"actions\")) {\n        // checking security in action level\n        let tdActions = Object.keys(td.actions)\n        for (let i = 0; i < tdActions.length; i++) {\n            const curActionName = tdActions[i]\n            const curAction = td.actions[curActionName]\n\n            if (curAction.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curAction.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curAction.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"action_\" + curActionName + \"_title\"]: isStringObjectKeyValue(curAction.title, curAction.titles)\n                    })\n                }\n            }\n\n            if (curAction.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curAction.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curAction.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                         [\"action_\" + curActionName + \"_desc\"]: isStringObjectKeyValue(curAction.description, curAction.descriptions)\n                    })\n                }\n            }\n\n        }\n    }\n\n    if (td.hasOwnProperty(\"events\")) {\n        // checking security in event level\n        let tdEvents = Object.keys(td.events)\n        for (let i = 0; i < tdEvents.length; i++) {\n            const curEventName = tdEvents[i]\n            const curEvent = td.events[curEventName]\n\n            if (curEvent.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curEvent.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curEvent.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"event_\" + curEventName + \"_title\"]: isStringObjectKeyValue(curEvent.title, curEvent.titles)\n                    })\n                }\n            }\n\n            if (curEvent.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curEvent.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curEvent.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"event_\" + curEventName + \"_desc\"]: isStringObjectKeyValue(curEvent.description, curEvent.descriptions)\n                    })\n                }\n            }\n\n        }\n    }\n    if(arrayArraysItemsEqual(multiLang)){\n        results.push({\n            \"ID\": \"td-multi-languages-consistent\",\n            \"Status\": \"pass\"\n        })\n    } else {\n        results.push({\n            \"ID\": \"td-multi-languages-consistent\",\n            \"Status\": \"fail\",\n            \"Comment\": \"not all multilang objects have same language tags\"\n        })\n    }\n\n    const flatArray = [] // this is multiLang but flat, so just a single array.\n    // This way we can have scan the whole thing at once and then find the element that is not bcp47\n\n    for (let index = 0; index < multiLang.length; index++) {\n        let arrayElement = multiLang[index]\n        arrayElement=JSON.parse(arrayElement)\n        for (let e = 0; e < arrayElement.length; e++) {\n            const stringElement = arrayElement[e]\n            flatArray.push(stringElement)\n        }\n    }\n    const isBCP47 = checkBCP47array(flatArray)\n    if(isBCP47 === \"ok\"){\n        results.push({\n            \"ID\": \"td-multilanguage-language-tag\",\n            \"Status\": \"pass\"\n        })\n    } else {\n        results.push({\n            \"ID\": \"td-multilanguage-language-tag\",\n            \"Status\": \"fail\",\n            \"Comment\":isBCP47+\" is not a BCP47 tag\"\n        })\n    }\n\n    // // checking td-context-default-language-direction-script assertion\n    // results.push({\n    //     \"ID\": \"td-context-default-language-direction-script\",\n    //     \"Status\": checkAzeri(flatArray)\n    // })\n\n    // checking td-titles-descriptions assertion\n    // if there are no multilang, then it is not impl\n    if(isTdTitlesDescriptions.length === 0){\n        results.push({\n            \"ID\": \"td-titles-descriptions\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no multilang objects in the td\"\n        })\n        return results\n    }\n\n    // if at some point there was a false result, it is a fail\n    for (let index = 0; index < isTdTitlesDescriptions.length; index++) {\n        const element = isTdTitlesDescriptions[index]\n        const elementName = Object.keys(element)\n\n        if(element[elementName]){\n            // do nothing it is correct\n        } else {\n            results.push({\n                \"ID\": \"td-titles-descriptions\",\n                \"Status\": \"fail\",\n                \"Comment\": elementName+\" is not on the multilang object at the same level\"\n            })\n            return results\n        }\n    }\n    // there was no problem, so just put pass\n    results.push({\n        \"ID\": \"td-titles-descriptions\",\n        \"Status\": \"pass\"\n    })\n\n    // ? nothing after this, there is return above\n    return results\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks if an array that contains only arrays as items is composed of same items\n *\n * @param {Array<object>} myArray The array to check\n */\nfunction arrayArraysItemsEqual(myArray) {\n    if(myArray.length === 0) return true\n    // first stringify each array item\n    for (let i = myArray.length; i--;) {\n        myArray[i] = JSON.stringify(myArray[i])\n    }\n\n    for (let i = myArray.length; i--;) {\n        if (i === 0) {\n            return true\n        }\n        if (myArray[i] !== myArray[i - 1]){\n            return false\n        }\n    }\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether the items of an array, which must be strings, are valid language tags\n *\n * @param {Array<string>} myArray The array, which items are to be checked\n */\nfunction checkBCP47array(myArray){\n    // return tag name if one is not valid during the check\n\n    for (let index = 0; index < myArray.length; index++) {\n        const element = myArray[index]\n        if (bcp47pattern.test(element)) {\n            // keep going\n        } else {\n            return element\n        }\n    }\n\n    // return true if reached the end\n    return \"ok\"\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether a given string exist as the value of key in an object\n *\n * @param {string} searchedString\n * @param {object} searchedObject\n */\nfunction isStringObjectKeyValue(searchedString, searchedObject){\n    const objKeys = Object.keys(searchedObject)\n    if(objKeys.length === 0) return false // if the object is empty, then the string cannot exist here\n    for (let index = 0; index < objKeys.length; index++) {\n        const element = objKeys[index]\n        if (searchedObject[element] === searchedString) {\n            return true // found where the string is in the object\n        } else {\n            // nothing keep going, maybe in another key\n        }\n    }\n    return false\n}\n\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether an azeri language tag also specifies the version (Latn or Arab).\n * basically if the language is called \"az\", it is invalid, if it is az-Latn or az-Arab it is valid.\n *\n * @param {Array<string>} myMultiLangArray The language array to check\n */\n// function checkAzeri(myMultiLangArray){\n//     for (let index = 0; index < myMultiLangArray.length; index++) {\n//         const element = myMultiLangArray[index]\n//         if (element ===\"az\"){\n//             return \"fail\"\n//         } else if ((element === \"az-Latn\") || (element === \"az-Arab\")){\n//             return \"pass\"\n//         }\n//     }\n//     // no azeri, so it is not implemented\n//     return \"not-impl\"\n// }\n\n// --------------------------------------------------\n\n// -------------------------------------------------- checkLinksRelTypeCount\n\n/**\n *  this checks whether rel:type appears only once in the links array\n *\n * @param {object} td The TD to do assertion tests\n */\nfunction checkLinksRelTypeCount(td){\n\n    const results = []\n\n    if (td.hasOwnProperty(\"links\")){\n        // links exist, check if there is rel type\n        let typeCount = 0\n        for (let i = 0; i < td.links.length; i++) {\n            const element = td.links[i]\n            if(element.hasOwnProperty(\"rel\")){\n                if (element.rel === \"type\"){\n                    typeCount++\n                }\n            }\n        }\n        if (typeCount === 0){\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no rel:type in any link\"\n            })\n        } else if (typeCount === 1){\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"fail\",\n                \"Comment\": \"too many rel:type in links array\"\n            })\n        }\n    } else {\n        results.push({\n            \"ID\": \"tm-rel-type-maximum\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no links array in the td\"\n        })\n    }\n    return results\n}\n\n/**\n * When you have apikey security with the key in uri, you put the name of the urivariable in the name field in\n * securityDefinitions. Ideally, that name appears in href as a uriVariable. See uriSecurity example\n * td-security-in-uri-variable: The URIs provided in interactions where a security scheme using uri as the value for\n * in MUST be a URI template including the defined variable.\n * Additionally, this also checks that the uriVariable used in the security does not conflict with ones for the TD\n * td-security-uri-variables-distinct: The names of URI variables declared in a SecurityScheme MUST be distinct from\n * all other URI variables declared in the TD.\n * @param {object} td The TD to do assertion tests\n */\nfunction checkUriSecurity(td) {\n\n    const results = []\n    if (td.hasOwnProperty(\"securityDefinitions\")) {\n        const securityDefinitionsObject = td.securityDefinitions\n        const securityDefinitionsNames = Object.keys(securityDefinitionsObject)\n\n        const securityUriVariables = [];\n        for (let index = 0; index < securityDefinitionsNames.length; index++) {\n            const curSecurityDefinition = securityDefinitionsObject[securityDefinitionsNames[index]];\n            if (curSecurityDefinition.scheme === \"apikey\"){\n                if (curSecurityDefinition.hasOwnProperty(\"in\")){\n                    if (curSecurityDefinition.in === \"uri\"){\n                        if (curSecurityDefinition.hasOwnProperty(\"name\")){\n                            securityUriVariables.push(curSecurityDefinition.name)\n                        }\n                    }\n                }\n            }\n        }\n\n        if (securityUriVariables.length === 0){ // we could not find any\n            results.push({\n                \"ID\": \"td-security-in-uri-variable\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no use of name in a uri apikey scheme\"\n            })\n            results.push({\n                \"ID\": \"td-security-uri-variables-distinct\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no use of name in a uri apikey scheme\"\n            })\n            return results\n        } else {\n            let uriVariablesResult = \"not-impl\"\n            let uriVariablesDistinctResult = \"not-impl\"\n            let rootUriVariables = [];\n            if (td.hasOwnProperty(\"uriVariables\")) {\n                rootUriVariables = Object.keys(td.uriVariables)\n            }\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking security in property level\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curProperty.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curProperty.hasOwnProperty(\"uriVariables\")){\n                        let curPropertyUriVariables = Object.keys(curProperty.uriVariables)\n                        curPropertyUriVariables.push(...rootUriVariables)\n                        if (curPropertyUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curPropertyUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curPropertyUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            if (td.hasOwnProperty(\"actions\")) {\n                // checking security in property level\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curAction.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curAction.hasOwnProperty(\"uriVariables\")){\n                        let curActionUriVariables = Object.keys(curAction.uriVariables)\n                        curActionUriVariables.push(...rootUriVariables)\n                        if (curActionUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curActionUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curActionUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            if (td.hasOwnProperty(\"events\")) {\n                // checking security in property level\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curEvent.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curEvent.hasOwnProperty(\"uriVariables\")){\n                        let curEventUriVariables = Object.keys(curEvent.uriVariables)\n                        curEventUriVariables.push(...rootUriVariables)\n                        if (curEventUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curEventUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curEventUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            results.push({\n                \"ID\": \"td-security-in-uri-variable\",\n                \"Status\": uriVariablesResult\n            })\n            results.push({\n                \"ID\": \"td-security-in-uri-variable-distinct\",\n                \"Status\": uriVariablesDistinctResult\n            })\n            return results\n\n        }\n\n        // // no security used non defined scheme, passed test\n        // results.push({\n        //     \"ID\": \"td-security-scheme-name\",\n        //     \"Status\": \"pass\"\n        // })\n        // return results\n\n    }\n    return results\n}\n\n/**\n * When tm:optional uses a pointer, it should point to an actual affordance and only to an affordance, as said by\n * tm-tmOptional-resolver: The JSON Pointers of tm:optional MUST resolve to an entire interaction affordance Map definition.\n * JSON Schema checks for the syntax but cannot know if the pointed affordance exists.\n * This function checks that programmatically\n * @param {object} td The TD to do assertion tests\n */\nfunction checkTmOptionalPointer(td){\n    const results = []\n    if(td.hasOwnProperty(\"tm:optional\")){\n        td[\"tm:optional\"].forEach(element => {\n            // However, tm: optional values start with / so it should be removed first\n            element = element.substring(1)\n            element = element.replace(\"/\",\".\") // since the resolvePath uses . instead of /\n            const pathTarget = resolvePath(td,element,\"noTarget\")\n            if (pathTarget === \"noTarget\" || pathTarget === undefined) {\n                results.push({\n                    \"ID\": \"tm-tmOptional-resolver\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"tm:optional does not resolve to an affordance\"\n                })\n            } else {\n                results.push({\n                    \"ID\": \"tm-tmOptional-resolver\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        });\n    } else {\n        results.push({\n            \"ID\": \"tm-tmOptional-resolver\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no use of tm:optional\"\n        })\n    }\n\n    return results\n }\n","import jsonld from 'jsonld';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\nimport apply from 'ajv-formats-draft2019';\nimport lzs from 'lz-string';\n\nimport {\n    checkPropUniqueness,\n    checkSecurity,\n    checkMultiLangConsistency,\n    checkLinksRelTypeCount,\n    checkUriSecurity,\n    checkTmOptionalPointer\n} from './shared';\nimport tdSchema from './td-schema.json';\nimport fullTdSchema from './td-schema-full.json';\nimport tmSchema from './tm-schema.json';\n\nimport jsonValidator from 'json-dup-key-validator';\n\nexport { tdValidator, tmValidator, compress, decompress, checkTypos }\n\n/**\n * A function that provides the core functionality of the TD Playground.\n * @param {string} tdString The Thing Description to check as a string.\n * @param {function} logFunc (string) => void; Callback used to log the validation progress.\n * @param {object} options additional options, which checks should be executed\n * @returns {Promise<object>} Results of the validation as {report, details, detailComments} object\n */\nfunction tdValidator(tdString, logFunc, { checkDefaults = true, checkJsonLd = true }) {\n    return new Promise((res, rej) => {\n\n        // check input\n        if (typeof tdString !== \"string\") {\n            rej(\"Thing Description input should be a String\")\n        }\n\n        if (checkDefaults === undefined) {\n            checkDefaults = true\n        }\n        if (checkJsonLd === undefined) {\n            checkJsonLd = true\n        }\n        if (typeof logFunc !== \"function\") {\n            rej(\"Expected logFunc to be a function\")\n        }\n\n        // report that is returned by the function, possible values for every property:\n        // null -> not tested, \"passed\", \"failed\", \"warning\"\n        const report = {\n            json: null,\n            schema: null,\n            defaults: null,\n            jsonld: null,\n            additional: null\n        }\n        // changing the two following objects implies adjusting the tests accordingly\n        const details = {\n            enumConst: null,\n            propItems: null,\n            security: null,\n            propUniqueness: null,\n            multiLangConsistency: null,\n            linksRelTypeCount: null,\n            readWriteOnly: null,\n            uriVariableSecurity: null\n        }\n\n        const detailComments = {\n            enumConst: \"Checking whether a data schema has enum and const at the same time.\",\n            propItems: \"Checking whether a data schema has an object but not properties or array but no items.\",\n            security: \"Check if used Security definitions are properly defined previously.\",\n            propUniqueness: \"Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp.\",\n            multiLangConsistency: \"Checks whether all titles and descriptions have the same language fields.\",\n            linksRelTypeCount: \"Checks whether rel:type is used more than once in the links array\",\n            readWriteOnly: \"Warns if a property has readOnly or writeOnly set to true conflicting with another property.\",\n            uriVariableSecurity: \"Checks if the name of an APIKey security scheme with in:uri show up in href and does not conflict with normal uriVariables\"\n        }\n\n        const validationErrors = {\n            json: null,\n            schema: null\n        }\n\n        let tdJson\n        try {\n            tdJson = JSON.parse(tdString)\n            report.json = \"passed\"\n        } catch (err) {\n            report.json = \"failed\"\n            logFunc(\"X JSON validation failed:\")\n            validationErrors.json = err.message;\n            logFunc(err)\n\n            res({ report, details, detailComments, validationErrors })\n        }\n\n        let ajv = new Ajv({ strict: false }) // options can be passed, e.g. {allErrors: true}\n\n        // ajv = addFormats(ajv) // ajv does not support formats by default anymore\n        ajv = apply(ajv) // new formats that include iri\n\n\n        ajv.addSchema(tdSchema, 'td')\n        const valid = ajv.validate('td', tdJson)\n        // used to be var valid = ajv.validate('td', e.detail);\n        if (valid) {\n\n            report.schema = \"passed\"\n\n            // check with full schema\n            if (checkDefaults) {\n                ajv.addSchema(fullTdSchema, 'fulltd')\n                const fullValid = ajv.validate('fulltd', tdJson)\n                if (fullValid) {\n                    report.defaults = \"passed\"\n                } else {\n                    report.defaults = \"warning\"\n                    logFunc(\"Optional validation failed:\")\n                    logFunc(\"> \" + ajv.errorsText(filterErrorMessages(ajv.errors)))\n                    res({ report, details, detailComments, validationErrors })\n                }\n            }\n\n            // do additional checks\n            checkEnumConst(tdJson)\n            checkPropItems(tdJson)\n            checkReadWriteOnly(tdJson)\n            details.security = evalAssertion(checkSecurity(tdJson))\n            details.propUniqueness = evalAssertion(checkPropUniqueness(tdString))\n            if (details.propUniqueness === \"passed\") {\n                details.propUniqueness = checkSecPropUniqueness(tdString, tdJson)\n            } else {\n                checkSecPropUniqueness(tdString, tdJson)\n            }\n            details.multiLangConsistency = evalAssertion(checkMultiLangConsistency(tdJson))\n            details.linksRelTypeCount = evalAssertion(checkLinksRelTypeCount(tdJson))\n            details.uriVariableSecurity = evalAssertion(checkUriSecurity(tdJson))\n\n            // determine additional check state\n            // passed + warning -> warning\n            // passed AND OR warning + error -> error\n            report.additional = \"passed\"\n            Object.keys(details).forEach(prop => {\n                if (details[prop] === \"warning\" && report.additional === \"passed\") {\n                    report.additional = \"warning\"\n                } else if (details[prop] === \"failed\" && report.additional !== \"failed\") {\n                    report.additional = \"failed\"\n                }\n            })\n\n        } else {\n\n            report.schema = \"failed\"\n            logFunc(\"X JSON Schema validation failed:\")\n            validationErrors.schema = ajv.errorsText(filterErrorMessages(ajv.errors))\n            logFunc('> ' + validationErrors.schema)\n\n            res({ report, details, detailComments, validationErrors })\n        }\n\n        // json ld validation\n        if (checkJsonLd) {\n            jsonld.toRDF(tdJson, {\n                format: 'application/nquads'\n            }).then(nquads => {\n                report.jsonld = \"passed\"\n                res({ report, details, detailComments })\n            }, err => {\n                report.jsonld = \"failed\"\n                logFunc(\"X JSON-LD validation failed:\")\n                logFunc(\"Hint: Make sure you have internet connection available.\")\n                logFunc('> ' + err)\n                res({ report, details, detailComments })\n            })\n        } else {\n            res({ report, details, detailComments })\n        }\n\n\n        // ************ functions ***************\n\n        /** checking whether a data schema has enum and const at the same and displaying a warning in case there are */\n        function checkEnumConst(td) {\n            details.enumConst = \"passed\"\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n                    if (curProperty.hasOwnProperty(\"enum\") && curProperty.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In property ' + curPropertyName +\n                            ' enum and const are used at the same time, the values in enum' +\n                            ' can never be valid in the received JSON value')\n                    }\n                }\n            }\n            // checking actions\n            if (td.hasOwnProperty(\"actions\")) {\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"enum\") && curInput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the input of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"enum\") && curOutput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the output of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (td.hasOwnProperty(\"events\")) {\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n                    if (curEvent.hasOwnProperty(\"enum\") && curEvent.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In event ' + curEventName +\n                            ' enum and const are used at the same time, the' +\n                            ' values in enum can never be valid in the received JSON value')\n                    }\n                }\n            }\n            return\n        }\n\n        /**\n         * checking whether a data schema has object but not properties, array but no items\n         * @param {object} td The TD under test\n         */\n        function checkPropItems(td) {\n            details.propItems = \"passed\"\n\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n\n                    if (curProperty.hasOwnProperty(\"type\")) {\n                        if ((curProperty.type === \"object\") && !(curProperty.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curProperty.type === \"array\") && !(curProperty.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is array but its items are not specified')\n                        }\n                    }\n                }\n            }\n            // checking actions\n            if (td.hasOwnProperty(\"actions\")) {\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"type\")) {\n                            if ((curInput.type === \"object\") && !(curInput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the input of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curInput.type === \"array\") && !(curInput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"type\")) {\n                            if ((curOutput.type === \"object\") && !(curOutput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curOutput.type === \"array\") && !(curOutput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (td.hasOwnProperty(\"events\")) {\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n\n                    if (curEvent.hasOwnProperty(\"type\")) {\n                        if ((curEvent.type === \"object\") && !(curEvent.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curEvent.type === \"array\") && !(curEvent.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is array but its items are not specified')\n\n                        }\n                    }\n\n                }\n            }\n            return\n        }\n\n        /**\n         * Warns if a property has readOnly or writeOnly set to true conflicting with another property.\n         * @param {object} td The TD under test\n         */\n        function checkReadWriteOnly(td) {\n            details.readWriteOnly = \"passed\"\n\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n\n                    // if readOnly is set\n                    if (curProperty.hasOwnProperty(\"readOnly\") && curProperty.readOnly === true) {\n                        // check if both readOnly and writeOnly are true\n                        if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both readOnly and writeOnly are set to true!')\n                        }\n\n                        // check forms if op writeProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"writeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"writeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], readOnly is set but the op property contains \"writeproperty\"')\n                                        }\n                                    } else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], readOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // if writeOnly is set\n                    if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n\n                        // check forms if op readProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"readproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"readproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"readproperty\"')\n                                        } else if ((typeof formEl.op === \"string\" && formEl.op === \"observeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"observeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"observeproperty\"')\n                                        }\n                                    } else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], writeOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n\n                        // check if observable is also set\n                        if (curProperty.hasOwnProperty(\"observable\") && curProperty.observable === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both writeOnly and observable are set to true!')\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Warns if security Definitions has no unique keys\n         * @param {object} tdStr The TD under test as string\n         */\n        function checkSecPropUniqueness(tdStr, td) {\n\n            let result = \"passed\"\n            try {\n                // checking whether there are securityDefinitions at all\n                jsonValidator.parse(tdStr, false)\n            } catch (error) {\n                // there is a duplicate somewhere\n\n                // convert it into string to be able to process it\n                // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n                const errorString = error.toString()\n                // to get the name, we need to remove the quotes around it\n                const startQuote = errorString.indexOf('\"')\n                // slice to remove the part before the quote\n                const restString = errorString.slice(startQuote + 1)\n                // find where the interaction name ends\n                const endQuote = restString.indexOf('\"')\n                // finally get the interaction name\n                const securitySchemeName = restString.slice(0, endQuote)\n\n                if (td.securityDefinitions.hasOwnProperty(securitySchemeName)) {\n                    result = \"failed\"\n                    logFunc(\"KO Error: The securityDefinitions contain a duplicate\")\n                }\n            }\n\n            return result\n        }\n\n        /**\n         * Evaluates whether an assertion function contains a failed check\n         * Whether assertions are not-implemented or passed does not matter\n         * Logs the comment\n         * @param {Array} results Array of objects with props \"ID\", \"Status\" and optionally \"Comment\"\n         * @returns \"passed\" if no check failed, \"failed\" if one or more checks failed\n         */\n        function evalAssertion(results) {\n            let out = \"passed\"\n            results.forEach(resultobj => {\n                if (resultobj.Status === \"fail\") {\n                    out = \"failed\"\n                    logFunc(\"KO Error: Assertion: \" + resultobj.ID)\n                    logFunc(resultobj.Comment)\n                }\n            })\n            return out\n        }\n\n        /**\n         * Removes duplicate error messages, as these are produced\n         * otherwise, especially for \"oneOf\" schemes\n         * @param {ajv.ErrorObject[]} errors\n         */\n        function filterErrorMessages(errors) {\n\n            const output = []\n            errors.forEach(el => {\n                if (!output.some(ce => (ce.dataPath === el.dataPath && ce.message === el.message))) {\n                    output.push(el)\n                }\n            })\n            return output\n        }\n    })\n}\n/**\n * A function that provides the core functionality of the TD Playground.\n * @param {string} tmString The Thing Model to check as a string.\n * @param {function} logFunc (string) => void; Callback used to log the validation progress.\n * @param {object} options additional options, which checks should be executed\n * @returns {Promise<object>} Results of the validation as {report, details, detailComments} object\n */\nfunction tmValidator(tmString, logFunc, { checkDefaults = true, checkJsonLd = true }) {\n    return new Promise((res, rej) => {\n\n        // check input\n        if (typeof tmString !== \"string\") { rej(\"Thing Model input should be a String\") }\n\n        if (checkDefaults === undefined) {\n            checkDefaults = true\n        }\n        if (checkJsonLd === undefined) {\n            checkJsonLd = true\n        }\n        if (typeof logFunc !== \"function\") { rej(\"Expected logFunc to be a function\") }\n\n        // report that is returned by the function, possible values for every property:\n        // null -> not tested, \"passed\", \"failed\", \"warning\"\n        const report = {\n            json: null,\n            schema: null,\n            defaults: null,\n            jsonld: null,\n            additional: null\n        }\n        // changing the two following objects implies adjusting the tests accordingly\n        const details = {\n            enumConst: null,\n            propItems: null,\n            propUniqueness: null,\n            multiLangConsistency: null,\n            linksRelTypeCount: null,\n            readWriteOnly: null,\n            tmOptionalPointer: null\n        }\n\n        const detailComments = {\n            enumConst: \"Checking whether a data schema has enum and const at the same time.\",\n            propItems: \"Checking whether a data schema has an object but not properties or array but no items.\",\n            propUniqueness: \"Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp.\",\n            multiLangConsistency: \"Checks whether all titles and descriptions have the same language fields.\",\n            linksRelTypeCount: \"Checks whether rel:type is used more than once in the links array\",\n            readWriteOnly: \"Warns if a property has readOnly or writeOnly set to true conflicting with another property.\",\n            tmOptionalPointer: \"Checking whether tm:optional points to an actual affordance\"\n        }\n\n        let tmJson\n        try {\n            tmJson = JSON.parse(tmString)\n            report.json = \"passed\"\n        }\n        catch (err) {\n            report.json = \"failed\"\n            logFunc(\"X JSON validation failed:\")\n            logFunc(err)\n\n            res({ report, details, detailComments })\n        }\n\n        let ajv = new Ajv({ strict: false }) // options can be passed, e.g. {allErrors: true}\n        ajv = addFormats(ajv) // ajv does not support formats by default anymore\n        ajv = apply(ajv) // new formats that include iri\n\n        ajv.addSchema(tmSchema, 'tm')\n        const valid = ajv.validate('tm', tmJson)\n        // used to be var valid = ajv.validate('td', e.detail);\n        if (valid) {\n\n            report.schema = \"passed\"\n\n            // do additional checks\n            checkEnumConst(tmJson)\n            checkPropItems(tmJson)\n            checkReadWriteOnly(tmJson)\n            // ! no need to do security checking\n            // details.security = evalAssertion(checkSecurity(tmJson))\n            details.propUniqueness = evalAssertion(checkPropUniqueness(tmString))\n            if (details.propUniqueness === \"passed\") {\n                details.propUniqueness = checkSecPropUniqueness(tmString, tmJson)\n            }\n            else {\n                checkSecPropUniqueness(tmString, tmJson)\n            }\n            details.multiLangConsistency = evalAssertion(checkMultiLangConsistency(tmJson))\n            details.linksRelTypeCount = evalAssertion(checkLinksRelTypeCount(tmJson))\n            details.tmOptionalPointer = evalAssertion(checkTmOptionalPointer(tmJson))\n\n            // determine additional check state\n            // passed + warning -> warning\n            // passed AND OR warning + error -> error\n            report.additional = \"passed\"\n            Object.keys(details).forEach(prop => {\n                if (details[prop] === \"warning\" && report.additional === \"passed\") {\n                    report.additional = \"warning\"\n                }\n                else if (details[prop] === \"failed\" && report.additional !== \"failed\") {\n                    report.additional = \"failed\"\n                }\n            })\n\n        } else {\n\n            report.schema = \"failed\"\n            logFunc(\"X JSON Schema validation failed:\")\n\n            logFunc('> ' + ajv.errorsText(filterErrorMessages(ajv.errors)))\n\n            res({ report, details, detailComments })\n        }\n\n        // json ld validation\n        if (checkJsonLd) {\n            jsonld.toRDF(tmJson, {\n                format: 'application/nquads'\n            }).then(nquads => {\n                report.jsonld = \"passed\"\n                res({ report, details, detailComments })\n            }, err => {\n                report.jsonld = \"failed\"\n                logFunc(\"X JSON-LD validation failed:\")\n                logFunc(\"Hint: Make sure you have internet connection available.\")\n                logFunc('> ' + err)\n                res({ report, details, detailComments })\n            })\n        }\n        else {\n            res({ report, details, detailComments })\n        }\n\n\n        // ************ functions ***************\n\n        /** checking whether a data schema has enum and const at the same and displaying a warning in case there are */\n        function checkEnumConst(tm) {\n            details.enumConst = \"passed\"\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n                    if (curProperty.hasOwnProperty(\"enum\") && curProperty.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In property ' + curPropertyName +\n                            ' enum and const are used at the same time, the values in enum' +\n                            ' can never be valid in the received JSON value')\n                    }\n                }\n            }\n            // checking actions\n            if (tm.hasOwnProperty(\"actions\")) {\n                let tmActions = Object.keys(tm.actions)\n                for (let i = 0; i < tmActions.length; i++) {\n                    const curActionName = tmActions[i]\n                    const curAction = tm.actions[curActionName]\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"enum\") && curInput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the input of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"enum\") && curOutput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the output of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (tm.hasOwnProperty(\"events\")) {\n                let tmEvents = Object.keys(tm.events)\n                for (let i = 0; i < tmEvents.length; i++) {\n                    const curEventName = tmEvents[i]\n                    const curEvent = tm.events[curEventName]\n                    if (curEvent.hasOwnProperty(\"enum\") && curEvent.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In event ' + curEventName +\n                            ' enum and const are used at the same time, the' +\n                            ' values in enum can never be valid in the received JSON value')\n                    }\n                }\n            }\n            return\n        }\n\n        /**\n         * checking whether a data schema has object but not properties, array but no items\n         * @param {object} tm The TD under test\n         */\n        function checkPropItems(tm) {\n            details.propItems = \"passed\"\n\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n\n                    if (curProperty.hasOwnProperty(\"type\")) {\n                        if ((curProperty.type === \"object\") && !(curProperty.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curProperty.type === \"array\") && !(curProperty.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is array but its items are not specified')\n                        }\n                    }\n                }\n            }\n            // checking actions\n            if (tm.hasOwnProperty(\"actions\")) {\n                let tmActions = Object.keys(tm.actions)\n                for (let i = 0; i < tmActions.length; i++) {\n                    const curActionName = tmActions[i]\n                    const curAction = tm.actions[curActionName]\n\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"type\")) {\n                            if ((curInput.type === \"object\") && !(curInput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the input of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curInput.type === \"array\") && !(curInput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"type\")) {\n                            if ((curOutput.type === \"object\") && !(curOutput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curOutput.type === \"array\") && !(curOutput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (tm.hasOwnProperty(\"events\")) {\n                let tmEvents = Object.keys(tm.events)\n                for (let i = 0; i < tmEvents.length; i++) {\n                    const curEventName = tmEvents[i]\n                    const curEvent = tm.events[curEventName]\n\n                    if (curEvent.hasOwnProperty(\"type\")) {\n                        if ((curEvent.type === \"object\") && !(curEvent.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curEvent.type === \"array\") && !(curEvent.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is array but its items are not specified')\n\n                        }\n                    }\n\n                }\n            }\n            return\n        }\n\n        /**\n         * Warns if a property has readOnly or writeOnly set to true conflicting with another property.\n         * @param {object} tm The TD under test\n         */\n        function checkReadWriteOnly(tm) {\n            details.readWriteOnly = \"passed\"\n\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n\n                    // if readOnly is set\n                    if (curProperty.hasOwnProperty(\"readOnly\") && curProperty.readOnly === true) {\n                        // check if both readOnly and writeOnly are true\n                        if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both readOnly and writeOnly are set to true!')\n                        }\n\n                        // check forms if op writeProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"writeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"writeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], readOnly is set but the op property contains \"writeproperty\"')\n                                        }\n                                    }\n                                    else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], readOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // if writeOnly is set\n                    if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n\n                        // check forms if op readProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"readproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"readproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"readproperty\"')\n                                        }\n                                        else if ((typeof formEl.op === \"string\" && formEl.op === \"observeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"observeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"observeproperty\"')\n                                        }\n                                    }\n                                    else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], writeOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n\n                        // check if observable is also set\n                        if (curProperty.hasOwnProperty(\"observable\") && curProperty.observable === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both writeOnly and observable are set to true!')\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Warns if security Definitions has no unique keys\n         * @param {object} tmStr The TD under test as string\n         */\n        function checkSecPropUniqueness(tmStr, tm) {\n\n            let result = \"passed\"\n            try {\n                // checking whether there are securityDefinitions at all\n                jsonValidator.parse(tmStr, false)\n            }\n            catch (error) {\n                // there is a duplicate somewhere\n\n                // convert it into string to be able to process it\n                // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n                const errorString = error.toString()\n                // to get the name, we need to remove the quotes around it\n                const startQuote = errorString.indexOf('\"')\n                // slice to remove the part before the quote\n                const restString = errorString.slice(startQuote + 1)\n                // find where the interaction name ends\n                const endQuote = restString.indexOf('\"')\n                // finally get the interaction name\n                const securitySchemeName = restString.slice(0, endQuote)\n\n                if (tm.securityDefinitions.hasOwnProperty(securitySchemeName)) {\n                    result = \"failed\"\n                    logFunc(\"KO Error: The securityDefinitions contain a duplicate\")\n                }\n            }\n\n            return result\n        }\n\n        /**\n         * Evaluates whether an assertion function contains a failed check\n         * Whether assertions are not-implemented or passed does not matter\n         * Logs the comment\n         * @param {Array} results Array of objects with props \"ID\", \"Status\" and optionally \"Comment\"\n         * @returns \"passed\" if no check failed, \"failed\" if one or more checks failed\n         */\n        function evalAssertion(results) {\n            let out = \"passed\"\n            results.forEach(resultobj => {\n                if (resultobj.Status === \"fail\") {\n                    out = \"failed\"\n                    logFunc(\"KO Error: Assertion: \" + resultobj.ID)\n                    logFunc(resultobj.Comment)\n                }\n            })\n            return out\n        }\n\n        /**\n         * Removes duplicate error messages, as these are produced\n         * otherwise, especially for \"oneOf\" schemes\n         * @param {ajv.ErrorObject[]} errors\n         */\n        function filterErrorMessages(errors) {\n\n            const output = []\n            errors.forEach(el => {\n                if (!output.some(ce => (ce.dataPath === el.dataPath && ce.message === el.message))) {\n                    output.push(el)\n                }\n            })\n            return output\n        }\n    })\n}\n\n/**\n * Transform an arbitrary string to another compressed URL-encoded string.\n * @param {string} data String to compress.\n * @returns {string} Compressed URL-encoded string.\n */\nfunction compress(data) {\n    return lzs.compressToEncodedURIComponent(data);\n}\n\n/**\n * Decompress a string compressed with the {@link compress} method.\n * @param {string} data Compressed URL-encoded string.\n * @returns {string} Original string.\n */\nfunction decompress(data) {\n    return lzs.decompressFromEncodedURIComponent(data);\n}\n\n// --------------------------------------------------\n\n// -------------------------------------------------- checkTypos\n\nconst REF = \"$ref\"\nconst PROPERTIES = \"properties\"\nconst ADDITONAL_PROPERTIES = \"additional_properties\"\nconst DATA_SCHEMA = \"dataSchema\"\nconst PATH = \"#/\"\nconst TYPO_LOOKUP_TABLE = createSchemaLookupTable(tdSchema)\n\n/**\n * Checks possible typos in a TD\n * @param {object} td The TD to apply typo check on\n * @returns List of possible typos where the typo consists of string value of typo itself and the message, another string value, to be prompted to the user for the fix\n */\nfunction checkTypos(td) {\n    const typos = []\n\n    const lookupTable = TYPO_LOOKUP_TABLE\n    const searchDepth = 1\n    const searchPath = PATH\n    let tdJson = {}\n\n    try {\n        tdJson = JSON.parse(td)\n    } catch (err) {\n        console.log(\"Error occurred while parsing JSON!\")\n    }\n\n    searchTypos(typos, tdJson, lookupTable, searchDepth, searchPath)\n\n    return typos\n}\n\n/**\n * Searching typos on a specific path and depth\n * @param {Array} typos The list that typo objects are stored\n * @param {object} tdJson JSON object of the TD\n * @param {Map} lookupTable The map that stores paths and their available word list according to their path depth\n * @param {integer} searchDepth The integer that decides the depth of the typo check search\n * @param {string} searchPath The string that decided the path of the typo check search\n */\nfunction searchTypos(typos, tdJson, lookupTable, searchDepth, searchPath) {\n    for (const key in tdJson) {\n        if (tdJson.hasOwnProperty(key)) {\n            const pathMap = lookupTable.get(searchDepth)\n            const wordSet = pathMap.get(searchPath)\n\n            if (wordSet.has(key)) {\n                continue\n            }\n\n            wordSet.forEach(word => {\n                if (doesTypoExist(key, word)) {\n                    typos.push({\n                        word: key,\n                        message: `Did you mean ${word}?`\n                    })\n\n                    return\n                }\n            })\n        }\n    }\n}\n\n/**\n * Creates a lookup table using JSON schema\n * @param {object} jsonSchema JSON Schema to create a lookup table from\n * @returns The map that constructs lookup table for typo check using TD Schema\n */\nfunction createSchemaLookupTable(jsonSchema) {\n    const lookupTable = new Map()\n    const filteredLookupTable = new Map()\n\n    findPathsInSchema(lookupTable, jsonSchema, PATH)\n\n    lookupTable.forEach((value, key) => {\n        if (value.size > 0) {\n            const pathDepth = (key.match(/\\//ig) || []).length\n\n            let pathDepthMap = filteredLookupTable.get(pathDepth)\n\n            if (pathDepthMap) {\n                pathDepthMap.set(key.replace(/^r/g, ''), value)\n                filteredLookupTable.set(pathDepth, pathDepthMap)\n            } else {\n                pathDepthMap = new Map()\n                pathDepthMap.set(key.replace(/^r/g, ''), value)\n                filteredLookupTable.set(pathDepth, pathDepthMap)\n            }\n        }\n    })\n\n    return filteredLookupTable\n}\n\n/**\n * Finds the paths under a parent path by parsing schema and adds them to a lookup table\n * @param {Map} lookupTable The map that stores the paths in the schema\n * @param {object} schema The schema to find the paths from\n * @param {string} path The parent path that search is going under\n */\nfunction findPathsInSchema(lookupTable, schema, path) {\n    const keys = new Set()\n\n    if (schema[REF]) {\n        if (path[0] === 'r' && schema[REF].includes(DATA_SCHEMA)) {\n            return\n        }\n\n        if (schema[REF].includes(DATA_SCHEMA)) {\n            path = 'r' + path\n        }\n\n        findPathsInSchema(getRefObjectOfSchema(tdSchema, schema[REF]), path)\n        return\n    }\n\n    if (schema['type'] === 'object') {\n        const properties = schema[PROPERTIES]\n        for (const key in properties) {\n            if (properties.hasOwnProperty(key)) {\n                if (key === REF) {\n                    if (path[0] === 'r' && properties[key].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (properties[key].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, properties[key]), path)\n                    return\n                } else {\n                    findPathsInSchema(properties[key], `${path}${key}/`)\n                    keys.add(key)\n                }\n            }\n        }\n\n        const additionalProperties = schema[ADDITONAL_PROPERTIES]\n        for (const key in additionalProperties) {\n            if (additionalProperties.hasOwnProperty(key)) {\n                if (key === REF) {\n                    if (path[0] === 'r' && additionalProperties[key].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (additionalProperties[key].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, additionalProperties[key]), `${path}*/`)\n                    return\n                }\n            }\n        }\n\n        putKeysToPath(lookupTable, path, keys)\n    }\n\n    if (schema['type'] === 'array') {\n        const items = schema['items']\n\n        for (const item in items) {\n            if (items.hasOwnProperty(item)) {\n                if (item === REF) {\n                    if (path[0] === 'r' && items[item].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (items[item].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, items[item]), path)\n                    return\n                }\n            }\n        }\n\n        putKeysToPath(lookupTable, path, keys)\n    }\n\n    for (const key in schema) {\n        if (schema.hasOwnProperty(key)) {\n            if (['allOf', 'oneOf', 'anyOf'].includes(key)) {\n                if (Array.isArray(schema[key])) {\n                    schema[key].forEach(element => {\n                        findPathsInSchema(element, path)\n                    })\n                }\n            }\n        }\n    }\n}\n\n/**\n * Stores the keys under a specific path\n * @param {Map} lookupTable The map that stores the paths in the schema\n * @param {string} path The path that is owner of the current keys\n * @param {Set} keys The set of keys that is going to be put\n */\nfunction putKeysToPath(lookupTable, path, keys) {\n    let pathKeys = lookupTable.get(path)\n\n    if (pathKeys) {\n        const union = new Set(pathKeys)\n        keys.forEach(k => {\n            union.add(k)\n        })\n\n        lookupTable.set(path, union)\n    } else {\n        lookupTable.set(path, keys)\n    }\n}\n\n/**\n * Gets the reference object in the schema\n * @param {object} schema The object that represent the schema\n * @param {string} ref The reference value in the schema\n * @returns The reference object the ref maps to\n */\nfunction getRefObjectOfSchema(schema, ref) {\n    const splitRef = ref.split('/')\n    if (splitRef[0] !== '#') {\n        console.log('Parsing not implemented for between files')\n        return\n    }\n\n    let result = schema\n\n    for (let i = 1; i < splitRef.length; i++) {\n        result = result[splitRef[i]]\n    }\n\n    return result\n}\n\n// Minimum similarity value to be able to say that two words are similar\nconst SIMILARITY_THRESHOLD = 0.85\n\n// Maximum value of length difference between two words\nconst MAX_LENGTH_DIFFERENCE = 2\n\n/**\n * Checks whether typo exists or not by comparing similarity of the two words\n * @param {string} actual The property name of the TD entered by user\n * @param {string} desired The desired property name that is retrieved from TD Schema\n * @returns Boolean value that tell whether typo exists or not\n */\nfunction doesTypoExist(actual, desired) {\n    if (Math.abs(actual.length - desired.length) > MAX_LENGTH_DIFFERENCE) {\n        return false\n    }\n\n    const similarity = calculateSimilarity(actual, desired)\n    return similarity > SIMILARITY_THRESHOLD && similarity !== 1.0\n}\n\n/**\n * Similarity of words calculated using Jaro-Winkler algorithm\n * @param {string} actual The property name of the TD entered by user\n * @param {string} desired The desired propert name that is retrieved from TD Schema\n * @returns Similarity of value the two inputs\n */\nfunction calculateSimilarity(actual, desired) {\n    let m = 0\n\n    if (actual.length === 0 || desired.length === 0) {\n        return 0\n    }\n\n    if (actual === desired) {\n        return 1\n    }\n\n    const range = Math.floor(Math.max(actual.length, desired.length) / 2) - 1\n    const actualMatches = new Array(actual.length)\n    const desiredMatches = new Array(desired.length)\n\n    // check lower and upper bounds to find the matches\n    for (let i = 0; i < actual.length; i++) {\n        const lowerBound = (i >= range) ? i - range : 0\n        const upperBound = (i + range <= desired.length) ? (i + range) : (desired.length - 1)\n\n        for (let j = lowerBound; j <= upperBound; j++) {\n            if (actualMatches[i] !== true && desiredMatches[j] !== true && actual[i] === desired[j]) {\n                m++\n                actualMatches[i] = desiredMatches[j] = true\n                break\n            }\n        }\n    }\n\n    if (m === 0) {\n        return 0\n    }\n\n    let k = 0\n    let transpositionCount = 0\n\n    // count transpositions\n    for (let i = 0; i < actual.length; i++) {\n        if (actualMatches[i] === true) {\n            let j = 0\n            for (j = k; j < desired.length; j++) {\n                if (desiredMatches[j] === true) {\n                    k = j + 1\n                    break\n                }\n            }\n\n            if (actual[i] !== desired[j]) {\n                transpositionCount++\n            }\n        }\n    }\n\n    let similarity = ((m / actual.length) + (m / desired.length) + ((m - (transpositionCount / 2)) / m)) / 3\n    let l = 0\n    const p = 0.1\n\n    // strengthen the similarity if the words start with same letters\n    if (similarity < 0.7) {\n        while (actual[l] === desired[l] && l < 4) {\n            l++\n        }\n\n        similarity = similarity + l * p * (1 - similarity)\n    }\n\n    return similarity\n}\n","/********************************************************************************\n * Copyright (c) 2018 - 2020 Contributors to the Eclipse Foundation\n * \n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n * \n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the W3C Software Notice and\n * \n * SPDX-License-Identifier: EPL-2.0 OR W3C-20150513\n ********************************************************************************/\n\n/**\n* @param {Object} td\n* @returns {boolean}\n*\n* @description\n* isThingModel takes an object as argument and checks wether\n* it is a TD or a TM. If anything, but an object is passed,\n* the function will return false by default.\n*/\nexport const isThingModel = (td) => {\n    if (!(typeof td === 'object' && !Array.isArray(td) && td !== null)) {\n        return false;\n    }\n\n    if (!td.hasOwnProperty(\"@type\")) {\n        return false;\n    }\n\n    return td[\"@type\"].indexOf(\"tm:ThingModel\") > -1;\n}\n\n/**\n * \n * @param {*} firstAttribute \n * @param {*} object \n * @param {*} dontRender is a list of keys that shouldn't be packed into the attribute list.\n * \n * @description\n * Parses all key-value pairs of an object into an object'. \n * \n */\nexport const buildAttributeListObject = (firstAttribute, object, dontRender) => {\n    let attributeListObject = { ...firstAttribute }\n\n    for (const [key, value] of Object.entries(object)) {\n        if (!dontRender.includes(key)) {\n            attributeListObject[key] = value\n        }\n    }\n\n    return attributeListObject;\n}\n\n/**\n * \n * @param {*} forms \n * \n * @description\n * Converts Forms that have an array as the \"op\" value into multiple separate Forms \n * which only have a string as \"op\" value.\n */\nexport const separateForms = (forms) => {\n    if (forms === undefined && !forms) {\n        return []\n    }\n\n    const newForms = [];\n\n    for (let i = 0; i < forms.length; i++) {\n        const form = forms[i];\n\n        if (!Array.isArray(form.op)) {\n            newForms.push(form);\n            continue;\n        }\n\n        for (let i = 0; i < form.op.length; i++) {\n            const temp = { ...form };\n            temp.op = form.op[i];\n            newForms.push(temp);\n        }\n    }\n\n    return newForms;\n}\n\n\n\n\n/**\n * \n * @param {itemToCheck} itemToCheck \n * \n * Checks if item contains Forms\n * \n */\nexport const hasForms = (itemToCheck) => {\n    return itemToCheck.forms ? true : false;\n}\n\n/**   \n  *Check if link exists in the links section of iteamToCheck  \n*/\nexport const hasLinks = (itemToCheck) => {\n    return itemToCheck.links ? true : false;\n}\n\n/**  \n  *Check if link exists in the links section of iteamToCheck \n*/\nexport const checkIfLinkIsInItem = (link, itemToCheck) => {\n    for (const element of itemToCheck.links) {\n        if (element.href === link.href) {\n            return true;\n        }\n    }\n    return false;\n\n}\nexport const checkIfFormIsInItem = (form, itemToCheck) => {\n    for (const element of itemToCheck.forms) {\n        if (typeof (form.op) === \"string\") {\n            return checkIfFormIsInElement(form, element)\n        } else {\n            for (const x of form.op) {\n                if (typeof (element.op) === 'string') {\n                    if (element.op === x) {\n                        return true;\n                    }\n                } else {\n                    if (element.op.includes(x)) {\n                        let deepCompare = true;\n                        for (const y in form) {\n                            if (y !== 'op') {\n                                if (element[y] !== form[y]) {\n                                    deepCompare = false;\n                                }\n                            }\n                        }\n                        if (deepCompare)\n                            return true\n                    }\n                }\n            }\n        }\n    }\n    return false\n}\n\nconst checkIfFormIsInElement = (form, element) => {\n    if (typeof (element.op) === 'string') {\n        if (element.op === form.op) {\n            return true;\n        }\n    } else {\n        if (element.op.includes(form.op)) {\n            let deepCompare = true;\n            for (const y in form) {\n                if (y !== 'op') {\n                    if (element[y] !== form[y]) {\n                        deepCompare = false;\n                    }\n                }\n            }\n            if (deepCompare)\n                return true\n        }\n    }\n}\n\n/**\n    * Display the selected Thing description \n    * Save the current Thing Description if wanted\n    * Method supports both fileHandler and jsonld file\n*/\nexport const changeBetweenTd = async (context, href) => {\n    var writable\n    if (context.linkedTd[href][\"kind\"] === \"file\") {\n        try {\n            if (context.isModified && context.fileHandle) {\n                writable = await context.fileHandle.createWritable();\n                await writable.write(context.offlineTD);\n                await writable.close();\n            }\n        } catch (e) {\n            console.error(e.message);\n        }\n        let fileHandle = context.linkedTd[href];\n        const file = await fileHandle.getFile();\n        const td = JSON.parse(await file.text());\n        let offlineTd = JSON.stringify(td, null, 2);\n        context.setFileHandle(fileHandle);\n        context.updateOfflineTD(offlineTd);\n        context.updateIsModified(false);\n        document.getElementById(\"linkedTd\").value = href;\n    }\n    // If we create a TD using the New button then we don't have a file handler\n    // In that case the entry in linkedTd is not a file handler but a Thing Description Json \n    else if (Object.keys(context.linkedTd[href]).length) {\n        try {\n            if (context.isModified && context.fileHandle) {\n                writable = await context.fileHandle.createWritable();\n                await writable.write(context.offlineTD);\n                await writable.close();\n            }\n        } catch (e) {\n            console.error(e.message);\n        }\n        context.setFileHandle(undefined);\n        const td = context.linkedTd[href];\n        let offlineTd = JSON.stringify(td, null, 2);\n        context.updateOfflineTD(offlineTd);\n        context.updateIsModified(false);\n        document.getElementById(\"linkedTd\").value = href;\n\n    }\n}\n\n/**\n * @param {*} source Source object\n * @param {string} key Source key\n * @param {*} atContext Respective @context value\n * \n * @returns {string} String value of source[key] with prepended LRI or RLI symbol\n *\n * @description\n * Returns the value of source[key] with the direction information (rtl/ltr).\n */\nexport const getDirectedValue = (source, key, atContext) => {\n    // if there is no value to be directed this function returns\n    // to prevent any further call on undefined errors.\n    if (!source[key]) {\n        return \"\";\n    }\n\n    const LRI = '\\u2066';\n    const RLI = '\\u2067';\n    const TABLE = {\n        ar: 'rtl',\n        fa: 'rtl',\n        ps: 'rtl',\n        ur: 'rtl',\n        hy: 'ltr',\n        as: 'ltr',\n        bn: 'ltr',\n        zb: 'ltr',\n        ab: 'ltr',\n        be: 'ltr',\n        bg: 'ltr',\n        kk: 'ltr',\n        mk: 'ltr',\n        ru: 'ltr',\n        uk: 'ltr',\n        hi: 'ltr',\n        mr: 'ltr',\n        ne: 'ltr',\n        ko: 'ltr',\n        ma: 'ltr',\n        am: 'ltr',\n        ti: 'ltr',\n        ka: 'ltr',\n        el: 'ltr',\n        gu: 'ltr',\n        pa: 'ltr',\n        he: 'rtl',\n        iw: 'rtl',\n        yi: 'rtl',\n        ja: 'ltr',\n        km: 'ltr',\n        kn: 'ltr',\n        lo: 'ltr',\n        af: 'ltr',\n        ay: 'ltr',\n        bs: 'ltr',\n        ca: 'ltr',\n        ch: 'ltr',\n        cs: 'ltr',\n        cy: 'ltr',\n        da: 'ltr',\n        de: 'ltr',\n        en: 'ltr',\n        eo: 'ltr',\n        es: 'ltr',\n        et: 'ltr',\n        eu: 'ltr',\n        fi: 'ltr',\n        fj: 'ltr',\n        fo: 'ltr',\n        fr: 'ltr',\n        fy: 'ltr',\n        ga: 'ltr',\n        gl: 'ltr',\n        gn: 'ltr',\n        gv: 'ltr',\n        hr: 'ltr',\n        ht: 'ltr',\n        hu: 'ltr',\n        id: 'ltr',\n        in: 'ltr',\n        is: 'ltr',\n        it: 'ltr',\n        kl: 'ltr',\n        la: 'ltr',\n        lb: 'ltr',\n        ln: 'ltr',\n        lt: 'ltr',\n        lv: 'ltr',\n        mg: 'ltr',\n        mh: 'ltr',\n        mo: 'ltr',\n        ms: 'ltr',\n        mt: 'ltr',\n        na: 'ltr',\n        nb: 'ltr',\n        nd: 'ltr',\n        nl: 'ltr',\n        nn: 'ltr',\n        no: 'ltr',\n        nr: 'ltr',\n        ny: 'ltr',\n        om: 'ltr',\n        pl: 'ltr',\n        pt: 'ltr',\n        qu: 'ltr',\n        rm: 'ltr',\n        rn: 'ltr',\n        ro: 'ltr',\n        rw: 'ltr',\n        sg: 'ltr',\n        sk: 'ltr',\n        sl: 'ltr',\n        sm: 'ltr',\n        so: 'ltr',\n        sq: 'ltr',\n        ss: 'ltr',\n        st: 'ltr',\n        sv: 'ltr',\n        sw: 'ltr',\n        tl: 'ltr',\n        tn: 'ltr',\n        to: 'ltr',\n        tr: 'ltr',\n        ts: 'ltr',\n        ve: 'ltr',\n        vi: 'ltr',\n        xh: 'ltr',\n        zu: 'ltr',\n        ds: 'ltr',\n        gs: 'ltr',\n        hs: 'ltr',\n        me: 'ltr',\n        ni: 'ltr',\n        ns: 'ltr',\n        te: 'ltr',\n        tk: 'ltr',\n        tm: 'ltr',\n        tp: 'ltr',\n        tv: 'ltr',\n        ml: 'ltr',\n        my: 'ltr',\n        nq: 'ltr',\n        or: 'ltr',\n        si: 'ltr',\n        ta: 'ltr',\n        dv: 'rtl',\n        th: 'ltr',\n        dz: 'ltr'\n    };\n\n    const getDirectionSymbol = dir => (dir === 'ltr') ? LRI : RLI;\n\n    // title, description and language tags (like \"en\" or \"en-US\") are treated differently\n    if (!['title', 'description'].includes(key) && !/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)) {\n        return getDirectionSymbol(source[key].toString().getDirection()) + source[key];\n    }\n\n    if (/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)) {\n        // Language tags can be compound like ar-EG or en-US, split when needed\n        // Also, we ignore the case for language tags\n        const lookupKey = (key.includes('-')) ? key.split('-')[0] : key.toLowerCase();\n        const dir = TABLE[lookupKey];\n        if (dir) return getDirectionSymbol(dir) + source[key];\n        return getDirectionSymbol('ltr') + source[key];\n    }\n\n    let direction;\n    let lang;\n\n    if (!Array.isArray(atContext)) {\n        atContext = [atContext];\n    }\n\n    atContext.forEach(e => {\n        if (typeof e === 'object') {\n            if (e['@direction']) direction = e['@direction'];\n            if (e['@language']) lang = e['@language'];\n        }\n    });\n\n    if (key === 'title' || key === 'description') {\n        if (direction) return getDirectionSymbol(direction) + source[key];\n        if (lang) {\n            const lookupKey = (lang.includes('-')) ? lang.split('-')[0] : lang.toLowerCase();\n            const dir = TABLE[lookupKey];\n            if (dir) return getDirectionSymbol(dir) + source[key];\n            return getDirectionSymbol('ltr') + source[key];\n        }\n    }\n\n    return getDirectionSymbol(source[key].toString().getDirection()) + source[key];\n}\n","import { tdValidator, tmValidator } from \"../external/TdPlayground\";\nimport { isThingModel } from \"../util\"\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = async (message) => {\n    console.debug(\"validation worker received message...\");\n    let tdStr = message.data;\n\n    let td = {};\n    try {\n        td = JSON.parse(message.data);\n    } catch (e) {\n        console.debug(`ran into error while parsing TD: ${e}`)\n        postMessage(undefined);\n    }\n\n    try {\n        let result = undefined;\n        if (td && isThingModel(td)) {\n            result = await tmValidator(tdStr, console.debug, {});\n        } else {\n            result = await tdValidator(tdStr, console.debug, {});\n        }\n        postMessage(result);\n    } catch (e) {\n        postMessage(undefined);\n        console.debug(e);\n    }\n\n    console.debug(\"validation worker sent response...\");\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [507], function() { return __webpack_require__(27546); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"0608e7cc\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/editdor/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t892: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkeditdor\"] = self[\"webpackChunkeditdor\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(507).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["bcp47pattern","resolvePath","object","path","defaultValue","split","filter","p","reduce","o","checkPropUniqueness","tdString","results","jsonValidator","td","JSON","parse","hasOwnProperty","push","error","errorString","toString","startQuote","indexOf","restString","slice","endQuote","interactionName","properties","replace","actions","events","securityContains","parent","child","every","elem","checkMultiLangConsistency","multiLang","isTdTitlesDescriptions","rootTitlesObject","titles","rootTitles","Object","keys","_defineProperty","isStringObjectKeyValue","title","rootDescriptionsObject","descriptions","rootDescriptions","description","tdProperties","i","length","curPropertyName","curProperty","titlesKeys","descriptionsKeys","tdActions","curActionName","curAction","tdEvents","curEventName","curEvent","myArray","stringify","arrayArraysItemsEqual","flatArray","index","arrayElement","e","stringElement","isBCP47","element","test","checkBCP47array","elementName","searchedString","searchedObject","objKeys","checkLinksRelTypeCount","typeCount","links","rel","tdValidator","logFunc","_ref","_ref$checkDefaults","checkDefaults","_ref$checkJsonLd","checkJsonLd","Promise","res","rej","undefined","tdJson","report","json","schema","defaults","jsonld","additional","details","enumConst","propItems","security","propUniqueness","multiLangConsistency","linksRelTypeCount","readWriteOnly","uriVariableSecurity","detailComments","validationErrors","err","message","ajv","Ajv","strict","apply","addSchema","tdSchema","validate","fullTdSchema","errorsText","filterErrorMessages","errors","curInput","input","curOutput","output","checkEnumConst","type","checkPropItems","readOnly","writeOnly","formElIndex","forms","formEl","op","some","el","observable","checkReadWriteOnly","evalAssertion","securityDefinitionsObject","securityDefinitions","curForms","j","curForm","checkSecurity","checkSecPropUniqueness","securityDefinitionsNames","securityUriVariables","curSecurityDefinition","scheme","in","name","uriVariablesResult","uriVariablesDistinctResult","rootUriVariables","uriVariables","_loop","curHref","href","v","includes","curPropertyUriVariables","_toConsumableArray","value","_loop2","curActionUriVariables","_loop3","curEventUriVariables","checkUriSecurity","forEach","prop","tdStr","result","securitySchemeName","out","resultobj","Status","ID","Comment","ce","dataPath","format","then","nquads","tmValidator","tmString","_ref2","_ref2$checkDefaults","_ref2$checkJsonLd","tmJson","tmOptionalPointer","tmStr","tm","addFormats","tmSchema","tmProperties","tmActions","tmEvents","substring","pathTarget","checkTmOptionalPointer","REF","PROPERTIES","ADDITONAL_PROPERTIES","DATA_SCHEMA","PATH","jsonSchema","lookupTable","Map","filteredLookupTable","findPathsInSchema","key","size","pathDepth","match","pathDepthMap","get","set","createSchemaLookupTable","Set","getRefObjectOfSchema","concat","add","additionalProperties","putKeysToPath","items","item","Array","isArray","pathKeys","union","k","ref","splitRef","console","log","isThingModel","self","onmessage","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_context","prev","next","debug","data","postMessage","sent","t0","stop","_x","arguments","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","splice","r","n","getter","__esModule","d","a","definition","defineProperty","enumerable","f","chunkId","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prototype","Symbol","toStringTag","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}